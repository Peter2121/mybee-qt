pragma Singleton
import QtQuick 2.15

import CppCustomModules 1.0

Item {
    id: control

    readonly property string myClassName: control.toString().match(/.+?(?=_)/)[0]
    readonly property string configFile: "VirtualMachines.json"
    readonly property string cbsdName: "cbsd"
    readonly property string cbsdHome: SystemHelper.userHome(cbsdName)
    readonly property bool cbsdEnabled: cbsdHome && SystemHelper.groupMembers(cbsdName).includes(SystemHelper.userName)
    readonly property string cbsdSshKey: cbsdEnabled ? cbsdHome + "/.ssh/id_rsa" : ""
    property string cbsdPath: cbsdEnabled ? SystemHelper.findExecutable(cbsdName) : ""
    property var configArray: []
    property var currentConfig: ({})
    property int currentProgress: -1
    property bool clusterEnabled: false

    readonly property string sudoPswd: "Pswd"
    readonly property string sudoExec: "sudo -Sp" + sudoPswd
    readonly property string cbsdPrefix: Qt.platform.os === "unix" ? "b" : "q"
    property string cbsdProfiles: "get-profiles src=cloud"
    property string cbsdCluster:  "cluster"
    property string cbsdCreate:   cbsdPrefix + "create runasap=1 ci_ip4_addr=DHCP ci_gw4=10.0.0.1"
    property string cbsdStart:    cbsdPrefix + "start quiet=1"
    property string cbsdStop:     cbsdPrefix + "stop quiet=1"
    property string cbsdDestroy:  cbsdPrefix + "destroy"
    readonly property bool isBusy:    SystemProcess.running || HttpRequest.running
    readonly property bool isValid:   currentConfig.hasOwnProperty("server")
    readonly property bool isCreated: isValid && currentConfig.hasOwnProperty("id")
    readonly property bool isPowerOn: isCreated && (currentConfig["is_power_on"] === "true" || currentConfig["is_power_on"] === true)
    readonly property bool isSshUser: isPowerOn && currentConfig.hasOwnProperty("ssh_user")
    readonly property bool isRdpHost: isPowerOn && currentConfig.hasOwnProperty("rdp_user") && currentConfig.hasOwnProperty("rdp_host")
    readonly property bool isVncHost: isPowerOn && currentConfig.hasOwnProperty("vnc_host")

    readonly property string templateId: "vmTemplate"
    property string lastSelected: ""
    property int progressPeriod: 3 // seconds
    property int clusterPeriod: 60 // seconds
    readonly property int clusterDelay: 1000 // milliseconds

    signal message(string text)
    signal parseProfiles(string url, var array)
    signal listDone(string url)

    onCurrentConfigChanged: {
        if (!control.isValid) return
        var key = objectKey(currentConfig)
        if (key) lastSelected = key
    }
    //onLastSelectedChanged: console.debug("lastSelected", lastSelected)

    MySettings {
        category: control.myClassName
        property alias lastSelected: control.lastSelected
        property alias progressPeriod: control.progressPeriod
        property alias clusterPeriod: control.clusterPeriod

        property alias cbsdProfiles: control.cbsdProfiles
        property alias cbsdCluster:  control.cbsdCluster
        property alias cbsdCreate:   control.cbsdCreate
        property alias cbsdStart:    control.cbsdStart
        property alias cbsdStop:     control.cbsdStop
        property alias cbsdDestroy:  control.cbsdDestroy
    }

    Component.onCompleted: {
        setConfigArray()
        setCurrent(control.lastSelected)
    }

    Timer {
        interval: progressPeriod * 1000 // make milliseconds
        repeat: true
        running: interval >= 1000 && currentProgress >= 0
        triggeredOnStart: true
        onTriggered: {
            if (currentProgress < 0) {
                stop()
            } else if (control.isValid && currentConfig["server"].startsWith("http")) {
                RestApiSet.getStatus(currentConfig)
            }
        }
    }

    Timer {
        id: clusterTimer
        interval: clusterDelay
        repeat: true
        running: true
        onTriggered: {
            if (clusterEnabled && !control.isBusy && currentProgress < 0) {
                var period = Math.max(control.clusterPeriod, 30) * 1000 // make milliseconds
                if (interval !== period) {
                    interval = period
                    restart()
                }
                var list = SystemHelper.fileList(null, null, true)
                for (var folder of list) {
                    var cfg = SystemHelper.loadObject(folder + "/lastServer")
                    if (cfg.hasOwnProperty("server") && cfg.hasOwnProperty("ssh_key"))
                        getList(cfg)
                }
            } else if (interval !== clusterDelay) {
                interval = clusterDelay
                restart()
            }
        }
    }

    Connections {
        target: SystemProcess
        function onFinished(code) {
            message(cbsdPath + " return " + code)
            if (code || !cbsdPath) return
            var cmd = SystemProcess.command
            var pos = cmd.indexOf(cbsdName)
            if (pos < 0) return
            cmd = cmd.slice(pos + cbsdName.length + 1)
            if (cmd.startsWith(cbsdProfiles)) {
                parseProfiles("file:" + cbsdPath, SystemHelper.loadArray(cbsdName + "/profiles.json"))
                return
            }
            if (cmd.startsWith(cbsdCluster)) {
                var url = "file:" + cbsdPath
                parseCluster(url, SystemHelper.loadObject(cbsdName + "/cluster.json"))
                listDone(url)
                return
            }
            if (cmd.startsWith(cbsdCreate)) {
                parseCreate("file:" + cbsdPath)
            } else if (!cmd.startsWith(cbsdStart) && !cmd.startsWith(cbsdStop) && !cmd.startsWith(cbsdDestroy)) {
                message("Unexpected command " + SystemProcess.command)
                return
            }
            currentProgress = -1
            clusterTimer.interval = clusterDelay
            clusterTimer.restart()
        }
    }

    Connections {
        target: RestApiSet
        function onResponse(cmd, url, name) {
            var file = Url.hostAt(url) + '/' + RestApiSet.cmdName(cmd)
            switch (cmd) {
            case RestApiSet.Cmd.Profiles:
                parseProfiles(url, SystemHelper.loadArray(file))
                return
            case RestApiSet.Cmd.Create:
                parseCreate(url, SystemHelper.loadObject(file))
                return
            case RestApiSet.Cmd.Cluster:
                parseCluster(url, SystemHelper.loadObject(file))
                listDone(url)
                return
            case RestApiSet.Cmd.Status:
                if (!name) break
                parseStatus(url, name, SystemHelper.loadObject(file))
                return
            case RestApiSet.Cmd.Start:
            case RestApiSet.Cmd.Stop:
                if (!name) break
                parseStartStop(url, name, SystemHelper.loadObject(file))
                return
            case RestApiSet.Cmd.Destroy:
                if (SystemHelper.loadObject(file)["Message"] !== "destroy") break
                return
            }
            message(url + " unexpected response " + cmd)
        }
    }

    function executeCbsd(args, file) {
        //console.debug("executeCbsd", args, file)
        if (!cbsdPath) return
        if (!file) SystemProcess.stdOutFile = ""
        else if (SystemHelper.isAbsolute(file)) SystemProcess.stdOutFile = file
        else SystemProcess.stdOutFile = SystemHelper.appDataPath(cbsdName) + '/' + file

        SystemProcess.command = sudoExec + ' ' + cbsdPath + ' ' + args
        Qt.callLater(SystemProcess.start)
        message(SystemProcess.command)
    }

    function isSchemeEnabled(scheme) : bool {
        switch (scheme) {
        case "http":    return true
        case "https":   return HttpRequest.sslAvailable
        case "ssh":     return true
        case "file":    return cbsdEnabled
        }
        return false
    }

    function getProfiles(cfg) {
        var scheme = Url.schemeAt(cfg["server"])
        if (isSchemeEnabled(scheme)) {
            switch (scheme) {
            case "http":
            case "https":
                RestApiSet.getProfiles(cfg)
                return
            case "file":
                executeCbsd(cbsdProfiles + " json=1", "profiles.json")
                return
            }
        }
        message("getProfiles: Unsupported URL scheme: " + scheme)
    }

    function getList(cfg) {
        var scheme = Url.schemeAt(cfg["server"])
        if (isSchemeEnabled(scheme)) {
            switch (scheme) {
            case "http":
            case "https":
                RestApiSet.getCluster(cfg)
                return
            case "file":
                executeCbsd(cbsdCluster, "cluster.json")
                return
            }
        }
        message("getList: Unsupported URL scheme: " + scheme)
    }

    function createVm(cfg) {
        if (control.isCreated) return // just for sanity
        var scheme = Url.schemeAt(cfg["server"])
        if (isSchemeEnabled(scheme)) {
            switch (scheme) {
            case "http":
            case "https":
                RestApiSet.postCreate(cfg)
                return
            case "file":
                var cmd = cbsdCreate + " inter=0 jname=" + cfg["alias"]
                cmd += " vm_os_type=" + (cfg["vm_os_type"] ? cfg["vm_os_type"] : cfg["type"])
                cmd += " vm_os_profile=" + (cfg["vm_os_profile"] ? cfg["vm_os_profile"] : cfg["profile"])

                cmd += " imgsize="
                if (cfg["imgsize"]) cmd += cfg["imgsize"]
                else if (cfg["imgsize_bytes"]) cmd += cfg["imgsize_bytes"]
                else cmd += RestApiSet.defDiskSize + 'g'

                cmd += " vm_ram="
                if (cfg["ram"]) cmd += cfg["ram"]
                else if (cfg["ram_bytes"]) cmd += cfg["ram_bytes"]
                else cmd += RestApiSet.defRamSize + 'g'

                cmd += " vm_cpus="
                if (cfg["cpus"]) cmd += cfg["cpus"]
                else cmd += RestApiSet.defCpuCount

                currentProgress = 0
                executeCbsd(cmd)
                return
            }
        }
        message("createVm: Unsupported URL scheme: " + scheme)
    }

    function removeVm(cfg) {
        if (!cfg) cfg = currentConfig
        var key = objectKey(cfg)
        if (!key) {
            message("removeVm: Object not found")
            return
        }
        var conf_path = SystemHelper.fileName(cfg["server"]) + '/' + configFile
        var map = SystemHelper.loadObject(conf_path)
        if (!map.hasOwnProperty(key)) {
            message("removeVm: Config not found")
            return
        }
        var obj = map[key]
        delete map[key]
        if (!SystemHelper.saveObject(conf_path, map)) {
            message("removeVm: Can't write " + conf_path)
            return
        }
        setConfigArray()
        if (key === objectKey(currentConfig))
            setCurrent() // any first one or nothing

        var scheme = Url.schemeAt(obj["server"])
        if (isSchemeEnabled(scheme)) {
            switch (scheme) {
            case "http":
            case "https":
                RestApiSet.getDestroy(obj)
                return
            case "file":
                executeCbsd(cbsdDestroy + " jname=" + obj["id"])
                return
            }
        }
        message("removeVm: Unsupported URL scheme: " + scheme)
    }

    function startCurrent() {
        if (!control.isCreated) return // just for sanity
        var scheme = Url.schemeAt(currentConfig["server"])
        if (isSchemeEnabled(scheme)) {
            switch (scheme) {
            case "http":
            case "https":
                RestApiSet.getStart(currentConfig)
                return
            case "file":
                executeCbsd(cbsdStart + " inter=0 jname=" + currentConfig["id"])
                return
            }
        }
        message("startCurrent: Unsupported URL scheme: " + scheme)
    }

    function stopCurrent() {
        if (!control.isCreated) return // just for sanity
        var scheme = Url.schemeAt(currentConfig["server"])
        if (isSchemeEnabled(scheme)) {
            switch (scheme) {
            case "http":
            case "https":
                RestApiSet.getStop(currentConfig)
                return
            case "file":
                executeCbsd(cbsdStop + " jname=" + currentConfig["id"])
                return
            }
        }
        message("stopCurrent: Unsupported URL scheme: " + scheme)
    }

    /*function parseCbsdList(qls) {
        var hdr = [], list = []
        for (var line of qls) {
            if (!hdr.length) line = line.toLowerCase()
            var seq = line.split(' ').filter(Boolean)
            if (!seq.length) continue
            if (!hdr.length) hdr = seq
            else if (seq.length === hdr.length) {
                var obj = {}
                for (var i = 0; i < seq.length; i++) {
                    obj[hdr[i]] = /^\d+$/.test(seq[i]) ? parseInt(seq[i]) : seq[i]
                    switch (hdr[i]) {
                    case "jname": obj["id"] = seq[i]; break
                    case "vm_ram": obj["ram"] = Math.round(parseInt(seq[i]) / 1024) + 'g'; break
                    case "vm_cpus": obj["cpus"] = parseInt(seq[i]); break
                    case "status": obj["is_power_on"] = seq[i].toLowerCase() === "on"; break
                    case "vnc_port": if (parseInt(seq[i])) obj["vnc_host"] = "127.0.0.1"
                    }
                }
                list.push(obj)
            }
        }
        SystemHelper.saveArray(cbsdName + "/qls.json", list)
        parseCluster(cbsdPath, list)
    }*/

    /*function sshPrivateFile(url) : string {
        url = serverLocation(url ? url : currentConfig["server"])
        if (!url) return null
        var path = ""
        if (Url.schemeAt(url) !== "file") {
            var conf = SystemHelper.loadObject(Url.hostAt(url) + '/' + RestApiSet.authConfFile)
            if (!conf[RestApiSet.sshPrivName]) {
                conf = SystemHelper.loadObject(RestApiSet.authConfFile)
                if (conf[RestApiSet.sshPrivName]) path = conf[RestApiSet.sshPrivName]
            } else path = conf[RestApiSet.sshPrivName]
        } else path = cbsdSshKey
        return (path && SystemHelper.isSshPrivateKey(path)) ? path : null
    }*/

    function desktopUrl() : url {
        var url = currentConfig.hasOwnProperty("desktop") ? currentConfig["desktop"].toLowerCase() : ""
        if (control.isRdpHost && (!url || url === "rdp")) {
            url = "rdp://"
            if (currentConfig.hasOwnProperty("rdp_user")) url += currentConfig["rdp_user"]
            else if (currentConfig.hasOwnProperty("id"))  url += currentConfig["id"]
            else url += Qt.application.name
            if (currentConfig.hasOwnProperty("rdp_password"))
                url += ':' + currentConfig["rdp_password"]
            if (!currentConfig.hasOwnProperty("rdp_host")) return null
            url += '@' + currentConfig["rdp_host"]
            if (currentConfig.hasOwnProperty("rdp_port"))
                url += ':' + currentConfig["rdp_port"]
            return url
        }
        if (control.isVncHost && (!url || url === "vnc")) {
            url = "vnc://"
            if (currentConfig.hasOwnProperty("vnc_user")) url += currentConfig["vnc_user"]
            else if (currentConfig.hasOwnProperty("id"))  url += currentConfig["id"]
            else url += Qt.application.name
            if (currentConfig.hasOwnProperty("vnc_password"))
                url += ':' + currentConfig["vnc_password"]
            if (!currentConfig.hasOwnProperty("vnc_host")) return null
            //url += '@' + (Url.schemeAt(serverLocation(currentConfig["server"])) === "file" ? "127.0.0.1" : currentConfig["vnc_host"])
            //if (currentConfig.hasOwnProperty("vnc_port")) url += ':' + currentConfig["vnc_port"]
            url += "@192.168.1.33:5900" //XXX REMOVE IT!
            return url
        }
        message("Desktop feature not available")
        return null
    }

    function setConfigArray() {
        var array = [], cnt = 0, folders = SystemHelper.fileList(null, null, true)
        for (var folder of folders) {
            var list = SystemHelper.loadArray(folder + '/' + configFile)
            for (var i = 0; i < list.length; i++) {
                var obj = list[i]
                if (typeof obj !== "object" || Array.isArray(obj)) {
                    message("setConfigArray: Not an object: " + folder + '/' + i)
                    continue
                }
                if (!obj["server"] || !obj["ssh_key"]) {
                    message("setConfigArray: No server and/or ssh_key: " + folder + '/' + i)
                    continue
                }
                var scheme = Url.schemeAt(obj["server"])
                if (!isSchemeEnabled(scheme)) {
                    message("setConfigArray: Unsupported URL scheme: " + scheme)
                    continue
                }
                if (!obj["alias"]) {
                    obj["alias"] = (obj["id"] ? obj["id"] : (obj["vm_os_type"] + cnt++)) + '@' + folder
                    message("The newly discovered VM is given a name " + obj["alias"])
                }
                array.push(obj)
            }
        }
        configArray = array
    }

    function setCurrent(at) {
        if (configMap.hasOwnProperty(at)) {
            currentConfig = Object.assign({}, configMap[at])
            return
        }
        for (var key in configMap) { // to set the first existing one
            currentConfig = Object.assign({}, configMap[key])
            return
        }
        currentConfig = {}
    }

    function updateCurrent(config, replace = false) : bool {
        var key = objectKey(config)
        if (!key) return false
        var conf_path = SystemHelper.fileName(config["server"]) + '/' + configFile
        var map = SystemHelper.loadObject(conf_path)
        if (replace || !map[key]) map[key] = config
        else map[key] = Object.assign(map[key], config)
        if (!SystemHelper.saveObject(conf_path, map)) {
            message("updateCurrent can't write " + conf_path)
            return false
        }
        setConfigArray()
        currentConfig = Object.assign({}, map[key])
        return true
    }

    function vmInstanceId(obj) : string {
        if (obj && typeof obj === "object") {
            if (obj.hasOwnProperty("id")) return obj["id"]
            if (obj.hasOwnProperty("instanceid")) return obj["instanceid"]
        }
        return undefined
    }

    function parseCluster(url, reply) {
        var list = reply.hasOwnProperty("servers") ? reply["servers"] : []
        if (!list.length) return
        var profiles = []
        var base = SystemHelper.fileName(url)
        var conf_path = base + '/' + configFile
        var key, next_map = {}, curr_map = SystemHelper.loadObject(conf_path)
        for (var item of list) {
            if (typeof item !== "object" || Array.isArray(item)) continue
            key = vmInstanceId(item)
            if (!key) {
                message("The \"id\" of the Cluster response is missing " + url)
                return
            }
            key += '@' + base
            if (curr_map.hasOwnProperty(key)) {
                next_map[key] = Object.assign(curr_map[key], item)
                delete curr_map[key]
            } else next_map[key] = item

            if (!next_map[key].hasOwnProperty("alias"))  next_map[key]["alias"] = key
            if (!next_map[key].hasOwnProperty("server")) next_map[key]["server"] = url
            if (!next_map[key].hasOwnProperty("name")) {
                if (!profiles.length) profiles = SystemHelper.loadArray(base + "/profiles")
                var index = profiles.findIndex(obj => obj.profile === item["vm_os_profile"])
                next_map[key]["name"] = ~index ? profiles[index]["name"] : item["vm_os_profile"]
            }
        }
        var temp = control.templateId + '@'
        for (key in curr_map) {
            if (key.startsWith(temp)) next_map[key] = curr_map[key]
        }
        var keys = Object.keys(next_map)
        if (!keys.length) {
            console.debug("parseCluster: No next_map keys")
            return
        }
        if (!SystemHelper.saveObject(conf_path, next_map)) {
            message("parseCluster: Can't write " + conf_path)
            return
        }
        setConfigArray()
        if (control.isValid) {
            key = objectKey(currentConfig)
            if (next_map.hasOwnProperty(key)) {
                currentConfig = Object.assign({}, next_map[key])
                return
            }
        }
        if (keys.length > 1) keys.sort()
        setCurrent(keys[0])
    }

    function parseCreate(url, reply) {
        var id = vmInstanceId(reply)
        var temp = control.templateId + '@'
        var base = SystemHelper.fileName(url)
        var conf_path = base + '/' + configFile
        var map = SystemHelper.loadObject(conf_path)
        for (var key in map) {
            if (!key.startsWith(temp) || map[key].hasOwnProperty("id"))
                continue
            var pair = key.split('@')
            if (pair.length !== 2 || pair[1] !== base) {
                message("Found broken config key at " + key)
                continue
            }
            var obj = map[key]
            if (id) obj["id"] = id
            else if (obj["alias"]) obj["id"] = obj["alias"]
            else continue
            if (!obj.hasOwnProperty("server")) obj["server"] = url
            map[obj["id"] + '@' + base] = obj
            delete map[key]
            if (!SystemHelper.saveObject(conf_path, map)) {
                message("parseCreate can't write " + conf_path)
                continue
            }
            setConfigArray()
            if (key === objectKey(currentConfig)) {
                currentConfig = Object.assign(currentConfig, obj)
                currentProgress = id ? 0 : -1
            } else message("Unexpected Create response " + key)
            break
        }
    }

    function parseStatus(url, name, reply) {
        var base = SystemHelper.fileName(url)
        var key = name + '@' + base
        if (key !== objectKey(currentConfig, false)) {
            message("Unexpected Status response " + key)
            return
        }
        if (vmInstanceId(reply) !== name) {
            message("The Status response \"id\" missmatch request " + key)
            return
        }
        var pending = reply["status"] === "pending"
        if (pending) {
            if (reply.hasOwnProperty("progress")) {
                var progress = parseInt(reply["progress"])
                if (progress >= 0 && progress < 100) {
                    currentProgress = progress
                    return
                }
                delete reply["progress"]
            }
            delete reply["status"]
        }
        var conf_path = base + '/' + configFile
        var map = SystemHelper.loadObject(conf_path)
        map[key] = map.hasOwnProperty(key) ? Object.assign(map[key], reply) : reply
        if (SystemHelper.saveObject(conf_path, map)) {
            setConfigArray()
            currentConfig = Object.assign(currentConfig, reply)
        } else message("parseStatus can't write " + conf_path)
        currentProgress = -1
    }

    function parseStartStop(url, name, reply) {
        var base = SystemHelper.fileName(url)
        var key = name + '@' + base
        if (key !== objectKey(currentConfig, false)) {
            message("Unexpected Start/Stop response " + key)
            return
        }
        var msg = reply["Message"]
        if (msg === "started" || msg === "stopped") {
            currentConfig = Object.assign(currentConfig, reply)
            currentProgress = 0
        } else message("Unknown Start/Stop message " + url + ": " + msg)
    }

    function valueAt(varName) : string {
        return currentConfig.hasOwnProperty(varName) ? currentConfig[varName] : ""
    }

    function objectKey(config, template = true) : string {
        if (config.hasOwnProperty("server")) {
            var base = SystemHelper.fileName(config["server"])
            var id = vmInstanceId(config)
            if (template) return (id ? id : control.templateId) + '@' + base
            if (id) return id + '@' + base
            message("The \"id\" parameters is missing at " + config["name"])
        } else message("The \"server\" parameters is missing at " + config["name"])
        return null
    }

    function isUniqueValue(varName, value) {
        var temp = control.templateId + '@'
        var vlc = value.toLowerCase()
        for (var key in configMap) {
            if (key.startsWith(temp)) continue
            var obj = configMap[key]
            if (obj.hasOwnProperty(varName) && obj[varName].toLowerCase() === vlc)
                return false
        }
        return true
    }

    function uniqueValue(varName, valPrefix) : string {
        var temp = control.templateId + '@'
        var sample = valPrefix.toLowerCase(), list = []
        for (var key in configMap) {
            if (key.startsWith(temp)) continue
            var obj = configMap[key]
            if (obj.hasOwnProperty(varName) && obj[varName].toLowerCase().startsWith(sample)) {
                list.push(obj[varName])
                if (list.length > 1) list.sort()
            }
        }
        var last = 0
        if (list.length) {
            var str = list[list.length - 1], regex = /\d+/
            if (regex.test(str)) {
                var match = regex.exec(str)
                last = parseInt(match[0])
            }
        }
        last++
        return valPrefix + last.toString()
    }
}
